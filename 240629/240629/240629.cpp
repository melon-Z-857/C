#include<stdio.h>

////写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
////StructType是结构体类型名，MemberName是成员名。具体操作方法是：
////1、先将0转换为一个结构体类型的指针，相当于某个结构体的首地址是0。此时，每一个成员的偏移量就成了相对0的偏移量，这样就不需要减去首地址了。
////2、对该指针用->访问其成员，并取出地址，由于结构体起始地址为0，此时成员偏移量直接相当于对0的偏移量，所以得到的值直接就是对首地址的偏移量。
////3、取出该成员的地址，强转成size_t并打印，就求出了这个偏移量。
//#define offsetof(StructType, MemberName) (size_t)&(((StructType *)0)->MemberName)
//
//struct S {
//	char a;
//	int b;
//};
//
//int main() {
//
//	printf("%zd", offsetof(struct S, a));
//
//	return 0;
//}


////写一个宏，可以将一个整数的二进制位的奇数位和偶数位交换。
////交换奇偶位，需要先分别拿出奇偶位。既然是宏，分别拿出用循环不是很现实，那就用&这些位的方式来做。
////奇数位拿出，那就是要&上010101010101……，偶数位拿出，就是要&上101010101010……，对应十六进制分别是555……和aaa……，
////一般我们默认是32位整数，4位对应一位16进制就是8个5，8个a。通过& 0x55555555的方式拿出奇数位和& 0xaaaaaaa的方式拿出偶数位。
////奇数位左移一位就到了偶数位上，偶数位右移一位就到了奇数位上，最后两个数字或起来，就完成了交换。
////※这个宏只能完成32位以内的整形，要想完成64位的，那就将5和a的数量翻倍即可。
//#define SwapIntBit(n) (((n) & 0x55555555) << 1 | ((n) & 0xaaaaaaaa) >> 1)


